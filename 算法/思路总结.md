模式识别
### 经验
- 解算法题原则：空间换时间-
- 能用增强for就不用普通for
- 数组问题，返回列表则回溯；返回下标则双指针；返回子串则window
- 注意每轮更新的值（最长子序列等）不要定义成全局变量。
- 每个子问题统计完成后更新结果（一般在内层for/while之外）


### 链表
- 第一思路：双指针
	- 快慢：成环，中点

- 遍历时需要断开下一指针：多条新链表接到1条旧链表

### 数组
- 双指针：只需要考虑临界情况
	- 快慢：归并 排序 中点
	- 相向：反转 二分
- 滑动窗口：依赖区间内所有元素的状态。==处理子串==
	- 定长：快慢指针
	- 变长：快慢指针
	```
			int left = 0, right = 0;
			while (left < right && right < nums.size()) {
		    // 增大窗口（可增加条件）
		    window.add(nums[right]);
		    right++;
		    while (window needs shrink) {
		        // 缩小窗口（）
		        window.remove(nums[left]);
		        left++;}}
  ```
  
- nSum问题
- 前缀和：适用于快速、频繁地计算一个索引区间内的元素之和
	- `pre[i]`：原数组下标`i`==之前==的和(可避免单独处理空数组)
	- `pre[i]=nums[i-1]+pre[i-1]`
	- `pre[i][j]=pre[i-1][j]+matrix[i-1][j-1]+pre[i][j-1]-pre[i-1][j-1]`
- 差分数组：适用于频繁对原始数组的某个区间的元素进行增减
	- 一般以工具类实现
	- `dp[i]:nums[i]-nums[i-1]
	- `dp[i]+3 && dp[j+1]-3 => nums[i——j]均+3`
- 二分搜索：有序+相向指针 
- 各种排序

### 排列/组合/子集

**==决策树树树树树树树树树树树树树树树树枝枝枝枝！！！！！！！！！！！！！==

**回溯框架 ：路径(选择)+可选列表+结束条件
```
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return
           
    for 选择 in 选择列表:
	    //检查标记
        做选择
        backtrack(路径, 选择列表)
        撤销选择
        //标记
```
for循环遍历同层树枝，递归调用遍历某根树枝的下一层树枝

- 元素无重不可复选：
	- 排列：used[]数组标记。注意，当前路径上的used[i]均为true
	- 子集：保证元素相对顺序不变——用start控制遍历起点(start=i+1)
		- 注意取结果位置（前序位置）
		- **子集 == 组合**
- 元素可重不可复选：
	- 排列：排序，标记，剪枝
	- 子集：先排序，在遍历每个节点的树枝时剪掉和上一条相等的
- 元素无重可复选：
	- 排列：每层遍历起点为i

### 动态规划

- 三要素：**重叠子问题、最优子结构(子问题最值->原问题最值)、 状态转移方程
- 框架：
```
######## 自顶向下递归的动态规划
def dp(状态1, 状态2, ...):
    for 选择 in 所有可能的选择:
        进行状态转移
        result = 求最值(result, dp(状态1, 状态2, ...))
    return result

######## 自底向上迭代的动态规划
# 初始化 base case
dp[0][0][...] = base case
# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)

```

### 图
==遍历框架 DFS + visited[]标记==
##### 思考
- 建图-邻接表：graph[s]存放s指向的节点列表
- 


- 建图-邻接表+邻接矩阵。
- 环检测：dfs+visited+onpath
- 拓扑排序：将有向图拉平，使得方向一致
- 并查集
- 