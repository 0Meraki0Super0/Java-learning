
![[Pasted image 20240128090757.png]]
### 类加载器子系统

- 作用：加载class字节码文件，加载的类信息存在==方法区==
- 角色：class文件存在本地硬盘，执行时被加载到JVM并创建许多实例，称作DNA元数据模板。此过程需要*运输工具*——**类加载器（ClassLoader）**

##### 类加载过程
![[Pasted image 20240128092531.png]]
- 加载：
	- 通过**全限定类名**获取该类二进制字节流
	- 将该流代表的静态存储结构转为方法区的**运行时数据结构**
	- 在内存中生成一个该类的java.lang.Class对象，作为方法区数据的访问入口
- 验证：
	- 目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全
	- 主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证
- 准备：
	- 为类变量（static变量）分配内存并且设置默认初始值，即零值
	- 这里不包含用final修饰的static，因为final在**编译时**就会分配好了默认值，**准备阶段会显式初始化
	- 注意：这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中
- 解析：
	- 将**常量池内的符号引用转换为直接引用的过程**
	- 。
	- 
- 初始化：
	- ==类的初始化时机：==创建实例，访问静态变量 方法，反射（比如：Class.forName (“com.atguigu.Test”)），初始化子类，被标为启动类
	- 初始化阶段 == 执行类构造器方法`<clinit>()`。该方法是javac编译器自动收集类中**所有类变量**的赋值动作，以及静态代码块语句合并。
	- 虚拟机保证该方法在多线程下同步加锁

##### 类加载器分类

- JVM支持：启动(引导)类加载器（**Bootstrap ClassLoader**）和 自定义类加载器（**所有派生于抽象类ClassLoader的类加载器**）

- 启动类加载器：加载Java核心类库，无父加载器，加载 扩展类 和应用程序类加载器(均派生于Class Loader)
- 自定义类加载器：可隔离加载类，修改加载方式，防源码泄露···
	- 继承抽象类java.lang.ClassLoader，重写findclass()
	- 直接继承URIClassLoader类，这样就可以避免编写findclass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁
- **获取ClassLoader方法：**
	- `clazz.getClassLoader()` : class通常是通过调用`对象.getClass()` 或`Class.forName(全类名)` 方法获得
	- Thread.currentThread().getContextClassLoader()：获取线程上下文的类加载器

- 如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中

##### 双亲委派机制

- Java虚拟机对class文件采用的是**按需加载**的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由**自己的父类加载器**处理，它是一种任务委派模式
	- 请求最终到达顶层的 启动类加载器
	- 若父类无法完成类加载任务，子加载器才会自己尝试
	- 父类加载器一层一层往下分配任务，如果子类加载器能加载，则加载此类，如果将加载任务分配至系统类加载器也无法加载此类，则抛出异常
![[Pasted image 20240128103117.png]]
- 优势：
	- 避免类重复加载
	- 保护程序安全，防止核心API被随意篡改（如自定义java.lang.String类不会被系统加载器加载，而是由引导加载器加载核心类库的String）

- ==两个class对象相同==：
	- 全类名一致
	- 加载他们类的**ClassLoader实例对象**相同