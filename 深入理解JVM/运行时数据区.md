
类加载完成后，执行引擎可以使用该类，也会用到运行时数据库

![[Pasted image 20240128114347.png]]
### 结构
- 内存是非常重要的系统资源，通过磁盘或者网络IO得到的数据，都需要先加载到内存中，然后CPU从内存中获取数据进行读取，也就是说内存充当了CPU和磁盘之间的桥梁。JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。**不同的JVM对于内存的划分方式和管理机制存在着部分差异**。

- 每个JVM只有一个Runtime实例，即为运行时环境

- JVM线程：在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射
    - 当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收。
    - 操作系统负责将线程安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法
- 线程的内存空间：
	- 线程独有：独立包括程序计数器、栈、本地方法栈
	- 线程间共享：堆、堆外内存（永久代码或元空间、代码缓存）

### 程序计数器（PC寄存器）
### 本地方法接口

- 是Java调用非Java代码的接口。本地接口的作用是融合不同的编程语言为Java所用。
- 定义时，变量和方法只声明，不实现。

原因：**Java应用需要与Java外面的硬件环境交互，这是本地方法存在的主要原因**。如底层系统（操作系统，某些硬件等）

### 本地方法栈
1. **Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用**。
2. 本地方法栈，也是线程私有的。
3. 允许被实现成固定或者是可动态扩展的内存大小（在内存溢出方面和虚拟机栈相同）
    - 如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个stackoverflowError 异常。
    - 如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个outofMemoryError异常。
- **注意：**
	- 当线程调用一个本地方法时，它和虚拟机有同样权限（通过本地方法接口访问虚拟机内部运行时数据区，使用CPU内存，从堆中分配任意内存）

### 虚拟机栈
每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），**对应着一次次的Java方法调用**