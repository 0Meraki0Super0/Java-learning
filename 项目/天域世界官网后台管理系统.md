### 简介
- **一个公司门户网站的后台管理系统，用于管理员实时管理公司官网内容，包括上传、修改、管理以及服务器监控等操作**。
- 该系统采用了B/S架构，前后端分离，后端使用了SpringBoot、Spring、SpringMVC、Mybatis-Plus框架，数据库采用MySQL，利用Redis实现用户对象的缓存。前端采用了Vue2.0框架。
- 系统实现了基于用户角色、用户组和权重的权限控制，用户登录时生成用户权限列表存储在缓存中，并根据权限列表对接口进行权限校验。利用AOP自定义注解实现了接口权限校验，提高了系统的扩展能力和代码的可维护性。
- 主要功能包括对官网文章、图片、场景、全景图等数据的上传、修改和管理，用户可以通过管理系统实时修改官网页面内容。文件上传采用FTP方式，并实现了shp文件转换GeoJSON等功能。
### 个人职责

- **使用 AOP 自定义注解实现分接口的权限校验，使用 token 在 Redis 中与用户权限信息做对应管理**。 
	1. 对许多接口需要做权限校验，比如查看服务器内核信息、用户权限列表、日志等，上传、删除文件等
	2. 自定义注解@CheckPower
	3. 使用环绕通知@Around：
		- 目标方法前：1. 解析注解信息：从`@CheckPower`注解中获取请求的相关信息，如请求路径、权限名称、API描述等。2. 数据处理：将请求的路径信息插入到数据库中，以便后续的权限管理。3. 获取请求信息：从目标方法（就是在加了`@CheckPower`注解的方法）的参数中获取`HttpServletRequest`对象，用于获取请求的token。4. 获取用户信息：通过token从Redis中获取用户信息`SkyUserPower`，用于后续的权限判断。
		- 目标方法：jp.proceed()（ProceedingJoinPoint jp 可以调用+执行目标方法，获得返回值。并且可以访问目标方法的参数等信息）
		- 目标方法后：1. 在`jp.proceed()`方法调用之后，会获取到目标方法的返回值，可以根据需要对返回值进行处理。2. 当目标方法执行成功并返回结果时，可以根据返回值的不同进行不同的处理，比如记录日志、返回特定的结果等。3. 如果目标方法执行过程中发生了异常，环绕通知方法会捕获异常，并根据异常类型进行相应的处理，比如打印错误日志、返回错误信息等。
	4. 用户发起请求时，HTTP请求头里携带token。后端从request中解析Token获取用户信息，判断是管理员/普通用户然后根据用户信息去缓存中查询用户的权限列表，根据权限列表来进行权限校验。若为游客，则给默认权限（只读）
- **加入Redis作为高并发缓存策略，对热点信息请求先访问到Redis，缓解数据库压力**
	- 本网站主要的热点信息是==文章以及其浏览次数==
	- 对于文章内容：从数据库查询到文章放入结果对象返回后，将文章对象序列化为 JSON 字符串存入redis，以后查询时取出json对象再反序列化
	- 对于文章浏览次数：文章的浏览次数可能会因为用户的访问而频繁地增加，因此也需要缓存起来，以便快速地获取并显示给用户。某文章首次被访问时，从数据库查询浏览次数，存入redis。此后继续访问文章时，更新缓存中浏览次数。通过redisTemplate对象操作redis,递增指定文章ID的浏览次数 (redisTemplate.opsForValue().increment("article:" + articleId + ":views", 1))
- **使用Redis Set数据结构存储用户收藏信息：**
	- 复习redis常用数据结构：  
	 **String（字符串）**：存储一个字符串值，是 Redis 最基本的数据类型，可以存储字符串、整数或者浮点数。**Hash（哈希）**：存储字段和字段值的映射表，适合存储对象。比如可以将一个用户对象存储在一个 Hash 结构中，每个字段表示对象的一个属性。 **List（列表）**：一个链表结构，可以存储多个字符串值，可以在列表两端进行添加、删除操作，支持重复元素。**Set（集合）**：存储多个不重复的字符串值的无序集合，适合用来存储不重复的数据，比如点赞、收藏等。**Sorted Set（有序集合）(==ZSet==)**：与 Set 类似，但每个成员都关联了一个分数（score），可以根据分数排序，常用于排行榜等场景。
    - 当用户收藏某些信息时，将信息的唯一标识（ID）存储到Redis的Set中，
	    - 用户ID-------信息ID1,信息ID2,信息ID3
    - 当需要获取用户的收藏信息时，直接从Redis中获取对应用户ID的Set即可(Smembers 用户ID)
    - 使用Set数据结构可以保证收藏信息的唯一性，同时提供高效的添加、删除和查询操作。
- **基于ZSet实现TopN日志问题排行、警告推送功能**：
    - 系统记录了用户操作日志，其中可能包含了一些错误或异常的操作，这些被记录下来的异常操作可以称为“日志问题”。例：
    ```java
    if (!isItemAvailable) { // 如果库存不足，记录异常情况到问题日志 
    String message = String.format("Item %s is not available for purchase (quantity: %d) by user %s", itemId, quantity, userId); 
    Log.error(message); 
    throw new InsufficientInventoryException("Insufficient inventory for item " + itemId); }
```
    
    - 将日志问题信息存储在Redis的ZSet中，以问题ID(异常操作)作为成员，以问题发生次数作为分数。当有新的日志问题产生时，更新相应问题的分数。
    - 通过ZSet提供的排名功能，可以快速获取问题发生次数排名靠前的TopN问题，实现日志问题排行的功能。
    - 定期或实时地检查是否有某些问题出现次数超过了阈值，如果超过了阈值就可以触发警告推送功能，通知相关人员关注和处理这些问题
- **基于静态 ThreadLocal 封装了线程隔离的全局上下文对象**：
    
    - 在程序中使用ThreadLocal来存储全局上下文对象，保证在同一个线程中的多个方法调用之间可以共享上下文信息。
    - Web 应用程序会使用线程池来处理请求，不同请求可能会由不同的线程处理。在每个请求处理开始时，可以将当前请求所需的用户信息、请求参数、身份认证信息等存储到 `ThreadLocal` 中，然后在请求处理的任何地方都可以直接从 `ThreadLocal` 中获取这些信息，而无需通过参数传递或者重新查询数据库。
    - 这种方式适用于需要在请求处理过程中共享某些信息，并且这些信息在整个请求过程中都保持不变或者只读的情况下。例如，在拦截器中可以将用户身份信息存储到 `ThreadLocal` 中，在控制器、服务层、甚至持久化层都可以直接从 `ThreadLocal` 中获取用户身份信息，而不需要在方法参数中传递。
- **利用Spring AOP对Excel导出功能进行限流**：
    - 我们希望控制Excel导出的频率，防止大并发导出excel操作影响系统稳定性。使用Spring AOP在Excel导出方法上添加切面，实现限流逻辑。在切面中对导出请求进行限流处理，可以基于时间窗口或计数器等方式进行限制，防止导出请求过多导致内存溢出或系统负载过重。
    - 定义切面类+环绕通知，根据限流注解中定义的时间间隔（1min），最大请求次数（100次）
- **利用Mybatis插件对返回结果中包含的客户敏感数据进行脱敏：**
    - 数据库中某些字段包含客户敏感信息，须在返回前端之前对敏感数据进行脱敏处理
    - 自定义Mybatis插件，在DAO层拦截SQL查询操作，对用户查询结果中的手机号，邮箱地址中间几位替换为星号，以JSON对象形式返回浏览器。浏览器获取JSON数据后，使用JavaScript将用户信息动态地渲染到页面上。
	     1. **ModelAndView（后端渲染）：** 在后端渲染中，服务器端生成HTML页面，并将数据注入到HTML模板中，最终将渲染好的页面发送给客户端。Spring框架中的ModelAndView允许控制器方法设置模型数据，并指定要渲染的视图（HTML模板），框架会将模型数据填充到视图中，并将渲染后的HTML页面返回给客户端。
	    2. **JavaScript渲染（前端渲染）：** 在JavaScript渲染中，服务器端通常返回JSON或其他数据格式，而不是HTML页面。然后，客户端的JavaScript代码负责解析这些数据，并动态地更新页面内容。这种方式下，前端负责渲染整个页面，而后端仅仅提供数据。
	- 创建一个类，实现 MyBatis 的 `Interceptor` 接口，并实现其中的 `intercept` 方法，该方法用于拦截 SQL 查询操作。
	```java
	@Intercepts({ @Signature(type = Executor.class, method = "query", args = {MappedStatement.class, Object.class}) }) 
	public class SensitiveInfoInterceptor implements Interceptor { 
	@Override 
	public Object intercept(Invocation invocation) throws Throwable { 
	// 获取被拦截的方法参数 
	Object[] args = invocation.getArgs(); MappedStatement mappedStatement = (MappedStatement) args[0]; 
	Object parameter = args[1]; // 获取 SQL 命令的类型和内容 
	String sqlCommandType = mappedStatement.getSqlCommandType().toString(); 
	String sql = mappedStatement.getBoundSql(parameter).getSql(); // 在这里可以对 SQL 进行处理，比如替换敏感信息 // 假设我们要替换查询结果中的手机号码 
	if (sqlCommandType.equals("SELECT")) { // 执行 SQL 查询操作 
	Object result = invocation.proceed(); // TODO: 对查询结果进行处理，替换敏感信息 // 这里可以通过正则表达式等方式替换敏感信息 // 例如，将手机号码替换为**** // 示例代码：
			result = replaceSensitiveInfo(result); return result; } // 对于非查询操作，直接执行原始方法 return invocation.proceed(); } // 可以添加自定义的替换敏感信息的方法 // private Object replaceSensitiveInfo(Object result) { ... } @Override public Object plugin(Object target) { return Plugin.wrap(target, this); } @Override public void setProperties(Properties properties) { // 可以在这里配置插件的属性 } }
	
```

##### 日志
	 * @param logType 日志类型（登录、退出、删除、新增、修改）  
	 * @param logTable 增删改操作的表  
	 * @param logText 日志描述  
- 调用线程池，多线程执行方法
`threadService.insertLogs("新增","sky_user_group","新增用户组记录:"+skyUserGroup.getGid());`